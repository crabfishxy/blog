+++
date = '2025-06-16T23:21:20+08:00'
draft = true
title = 'HTTPS迷思'
+++
# 背景
之前以为自己对于HTTPS的了解已经比较深入，但最近发觉自己的理解还是有很多欠缺，仍有许多不理解的地方。因此希望从我自己思考的一些问题出发，来加深对于HTTPS（以及密码学应用）的一些理解，希望也能对于正在阅读这篇Blog的你能有帮助

# F&Q

- HTTPS是基于密码学原理的吗？

是的

- HTTPS是基于对称加密还是非对称加密？

同时基于两者。利用非对称加密，client可以验证网站的证书，以及交换master key；利用对称加密，client和server用master key加密需要传输的数据

- 能不利用非对称加密吗？

不能，因为无法在一个公开的信道上秘密地交换client和server的密钥

- 那非对称加密机制是如何工作的？

非对称加密需要两把密钥：公钥和私钥，我们从密码学的三个性质来看非对称加密的工作机制吧。

- 密码学需要保证哪三个性质呢？

Confidentiality, Integrity, Authenticity

- 如何保证Confidentiality（保密性）？

非对称加密的两把密钥，其中一个密钥加密的信息，只有另一把能解开。因此如果需要保证交流的保密性，则由一方使用公钥来加密（公钥可以在开放信道上传输）需要秘密传输的信息，只有拥有私钥的一方可以解密得到明文。

- 如何保证Integrity（完整性）？

通过数字签名的形式。为了防止信息被篡改，提供数据的一方需要用私钥来对数据的hash进行加密，接受数据的一方用公钥来解密签名，对比数据的hash

![Untitled](images/Untitled.png)

- 如何保证Authenticity（真实性）？

这是最难解决的一个问题。我如何证明“我”是“我”呢？听起来有点绕，但现实中其实也一直在遇到这样的问题。比如我们去移动公司办电话卡，需要实名认证，通过什么来实名呢？身份证，营业厅的员工通过将身份证的照片和我本人的脸进行对比，确认我就是身份证上那个叫‘xx’的人后，他才会给我办理电话卡。那为什么身份证这么可信呢？因为身份证代表了政府的公信力背书，政府不会滥发身份证，且每个公民都有自己的身份证；这边我们不去深究政府的公信力是如何建立的，也不去讨论我为什么是我，如何定义‘我’这一哲学问题。现在各大APP都需要实名认证，但注册的时候其实我们并没有经过身份证线下对比的情况，只是填写了手机号，但其实这也可以达成真实性这一目的，因为在移动营业厅办理手机号的过程中，身份的真实性进行了**传递**，身份证代表真实身份这一功能转嫁到了手机号上，各大APP默认拥有这个手机号的人就是真正的你了。当然一些敏感场景会需要额外的人脸和身份证认证的情况，这就是后话了。同样的，网络中的真实性也有类似的机制，叫做证书信任链，我们后面再细讲

- 那能不用对称加密吗？

可以，理论上可以全程非对称加密。但因为非对称加密性能远不如对称加密，因此两者结合是更好的选择

- 那能说说全流程吗？
1. 客户端建立连接
2. 连接建立完成后，服务端发送给客户端证书
3. 客户端验证证书有效性后，随机生成一个master key，使用public key加密并发送
4. 服务端收到加密后的master key，用私钥解密
5. 双方使用master key来开始进行真正的通信
- 证书以及证书信任链是什么？

证书就类似于网站的身份证，让网站证明和当前客户端进行通信的服务器属于这个网站。比如我现在正在使用notion撰写这篇文章，就以notion的证书为例：

![Untitled](images/Untitled%201.png)

可以看到证书包含了notion.so这一域名的基本信息，包括地区，证书有效期等等。同时，我们也可以看到证书中包含了notion的公钥。可是这些信息其实不足以证明我们在和真正的notion域名持有者在沟通，因为任何一个中间人攻击者都可以提供这些伪造的信息。

其实我们可以关注到“颁发者名称”这一信息，这意味着这个证书是颁发的，有一个公正的第三方（上图中的Cloudflare Inc ECC CA-3）介入了！但是这个第三方是谁，我们为什么又要相信他呢，以及如何证明这个证书是第三方颁发的呢？

先回答“如何证明这个证书是第三方颁发的”这一问题，notion的证书的签名其实是由Cloudflare 的私钥签名的，因此可以由Cloudflare的公钥验证，而我们看到Cloudflare的证书也一起下发了，所以我们也能获得Cloudflare的公钥来进行这一验证。

那我们为什么能相信Cloudflare的证书呢？这其实又回到了起点，也就是说这一信任推导关系终究需要一个终点。幸运的是，这一终点就在第三张证书中“Baltimore CyberTrust Root”，这张证书形式和前两张是一致的，但是他在操作系统内置的信任证书中，也就是说浏览器有一批预先信任的根证书，其他的证书信任关系由这批根证书推导而来。就像我们从出生起就相信父母，父母把我们送到学校，我们相信老师、同学、学校，毕业后找到工作，相信了公司、领导、同事，这其实也是一种信任传递。

倒着梳理一下刚才的顺序的话，就是Baltimo CyberTrust Root和Cloudflare达成了公式，颁布了证书给CloudFlare，用自己的私钥给CloudFlare证书进行了签名，而Cloudflare给notion做了签名，而我们因为浏览器信任了Bltimo，也因此新人了Cloudflare，信任了notion，一个信任链就此达成

![Untitled](images/Untitled%202.png)

当然，用户其实也可以自己选择信任其他的根证书，这就类似于尽管银行、手机支付app有各种安全的保障措施（密码、指纹、短信），但用户如果自己选择冒风险（比如相信诈骗电话），那么不管这些措施多么安全，其实都没有什么用。因此不管是在互联网还是现实生活，都需要有足够的安全意识才行。

- HTTPS能防范中间人攻击吗？

如果用户不轻易选择相信攻击者的证书，那么中间人是无法攻破HTTPS的防御机制的。

1.  如果在建立HTTPS链接过程中，中间人替换服务器的证书，会因为没有CA的签发，导致证书不被浏览器承认
2. 如果不进行替换，因为中间人没有服务器的私钥，所以中间人无法得知公钥加密后的master secret。对于之后的通信内容一无所知
- 我想给我自己的网站颁发证书该怎么找到能为我签发证书的机构呢？

国内的很多云服务商其实已经提供了这一功能，但我更推荐你使用[Let’sEncrypt](https://letsencrypt.org/zh-cn/how-it-works/)，它提供了一套自动、省心的证书自动签发机制。这是LetsEncrypt的运作机制：

![Untitled](images/Untitled%203.png)

![Untitled](images/Untitled%204.png)

1. 首先，Let’sEncrypt需要服务器安装支持Let’sEncrypt的证书管理软件。然后由证书管理软件来与Let’sEncrypt交互。Let’sEncrypt首先需要服务器生成一对密钥（注意，这对密钥和服务器与客户端交互的密钥不一样，是另一对独立生成的），然后要求服务器用私钥加密由Let’sEncrypt提供的Nonce（可以简单理解成随机值）并返回加密后的密文与公钥给Let’sEncrypt，由Let’sEncrypt用公钥解密认证
2. Let’sEncrypt要求服务器在指定路径下放置一个文件，然后验证这一文件。这一步是为了验证正在交互的服务器拥有对于这一域名的控制权。
3. 前两步完成后，第一步中的公钥就和域名关联起来了，之后申请证书、吊销证书都用这一密钥对来进行加密和解密。

有人可能会觉得这一步会被中间人攻破，因为在申请证书的时候服务器还没有HTTPS的证书，但这是不对的，因为服务器在发送密钥的时候是作为客户端的，是可以和Let'sEncrypt的服务器建立HTTPS连接的(Let’sEncrypt访问域名路径下的文件时确实是HTTP)